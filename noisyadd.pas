{$ifdef mswindows}{$apptype console}{$endif}
Program NoisyAdd;
// Simple, quick program to add prefix code at the beginning of a
// program, and suffix code, at the end of the program
//
// The compiler does look beyond the last period, so appending
// lines to a file will work
//
// Paul Robinson 2021-12-17

{$mode ObjFPC}{$H+}
uses
   windows, SysUtils;

Const
    PrefixText: Array [1..10] of String = (
    '{.Noisy - Header AutoGenerated ',  // post processor will close comment
    '{.Noisy} {$IFDEF Noisy}',
    '{,Noisy} {$INFO Entered ', // adds file name here
    '{.Noisy} {$ENDIF}',
    '',
    '',
    '',
    '',
    '',
    ''
    );

    SuffixText: Array [1..10] of String = (
    '{.Noisy - Footer AutoGenerated ',  // post processor will close comment
    '{.Noisy} {$IFDEF Noisy}',
    '{,Noisy} {$INFO ', // adds file name here
    '{.Noisy} {$ENDIF}',
    '',
    '',
    '',
    '',
    '',
    ''  
    );

    Extensions: Array[1 .. 5] of String =(
    'pp',
    'pas',
    'inc',
    '',
    ''
    );

   Months: array[1..12] of string[9]=
            ('January',   'February','March',    'April',
              'May',      'June',    'July',     'August',
              'September','October', 'November', 'December');

    Days: Array[0..6] of string[9]=
            ('Sunday','Monday','Tuesday','Wednesday',
            'Thursday','Friday','Saturday');

    path = '*';
    Attr = faAnyFile  ;
    SlashChar = '\';


Var
    IR,
    GlobalFileCount,
    J,
    i: integer;

    Infile,
    Outfile: text;

    TS: SystemTime;
    TimeStamp: String;



    // Converts a file name into directory, name, extension.
    // This removes the dot in the extension. To keep it,
    // remove the // in front of Ext := and insert it in
    // the line after it
    procedure SplitPath(const Path: UnicodeString; var Folder, Name, Ext: UnicodeString);
    var
        DotPos, SlashPos, i: Integer;
    begin
        Folder := '';
        Name := Path;
        Ext := '';

        DotPos := 0;
        SlashPos := 0;

        for i := Length(Path) downto 1 do
            if (Path[i] = '.') and (DotPos = 0) then
                DotPos := i
            else if (Path[i] = SlashChar) and (SlashPos = 0) then
                SlashPos := i;

        if DotPos > 0 then
        begin
            Name := Copy(Path, 1, DotPos - 1);
    //        Ext  := LowerCase(Copy(Path, DotPos, Length(Path) - DotPos + 1));
            Ext  := LowerCase(Copy(Path, DotPos+1, Length(Path) - DotPos + 1));
        end;

        if SlashPos > 0 then
        begin
            Folder := Copy(Path, 1, SlashPos);
            Name   := Copy(Path, SlashPos + 1, Length(Name) - SlashPos);
        end;

    end;

  Function CTS(Const CTime:SystemTime): AnsiString;
begin
   Result := Days[CTime.dayOfWeek]+
             ' '+Months[CTime.month]+
             ' '+IntToStr(CTime.day)+
             ', '+IntToStr(CTime.year)+
             ' '+IntToStr(CTime.Hour)+
             ':';
   if CTime.Minute < 10 then Result := Result+'0';
   Result := Result+ IntToStr(CTime.Minute)+':';
   if CTime.Second < 10 then Result := Result+'0';
   Result := Result+ IntToStr(CTime.Second);
end;

  // Recursively scan directories
  Procedure ScanFiles(
              Const Prefix: UnicodeString);  //< from where are we searching?
  var
     Rslt: TUnicodeSearchRec;    //< since this proc is recursive,
                                 //< this must be local
     FullName,     //< Full name
     Backup,       //< Name of backup
     Line,         //< A line of the file
     TheFilePath,  //< File name spliot into path
     TheNameOnly,  //< File Name w/o extenion
     TheExtension: UnicodeString; //< File Name extension

     Function isDirectory: boolean;
     begin
       result := (rslt.Attr And faDirectory) = faDirectory;
     end;

     procedure putback;
     begin // try to put file back
         close(infile);
         if renameFile(backup,FullName) then // we did
             Writeln('?Error ',IR,' Unable to read file "',
                     FullName,'" file skipped')
         else                   // can't put it back
             Writeln('Unable to restore file "',
                      FullName,'", renamed to ',Backup,
                     '" file skipped');
     end;

  begin // scanfiles

      If FindFirst(Prefix+Path,Attr,rslt) = 0 Then
      Repeat
          If (rslt.Name = '.') Or  (rslt.Name = '..') Then
              continue;  // skip parent and self

          if isDirectory then     // don't collect directory
                                  // but do scan it
                 ScanFiles(prefix+rslt.Name+SlashChar)  // recursive search
          else    // NOT a directory
          begin
             SplitPath(rslt.name,TheFilePath,TheNameOnly,TheExtension);

             For I := 1 to 5 do
             if Extensions[I]<>'' then
                 If theExtension = Extensions[I] then
                 begin           // We do want this one
                     FullName := Prefix+rslt.name;
                     Backup   := FullName + '.bak';
                     // rename to Fullname + .bak, e.g pascal.pas,bak
                     if FileExists(Backup) then
                     // erase old backup
                         If not DeleteFile(Backup) then
                         begin
                              Writeln('Uname to delete backup of "',
                                    FullName,'" file skipped');
                              break;  // exit FOR loop
                         end;
                     if not renameFile(FullName,backup) then
                     begin
                        Writeln('Unable to backup file "',
                                FullName,'" file skipped');
                        break;  // exit FOR loop
                     end;
                     Assign(Infile,Backup);
                     FileMode := 0; // open input file read only
                     {$I-} Reset(Infile); {$I+}
                     IR := IOResult;
                     if IR<>0 then
                     begin // try to put it back
                        putback;
                        break;
                     end;
                     Assign(Outfile,Fullname); // create replacement
                     {$I-} Rewrite(Outfile); {$I+}
                     IR := IOResult;
                     if IR<>0 then 
                     begin // try to put it back
                        putback;
                        break;
                     end;
                     For J := 1 to 10 do
                        if PrefixText[J]<>'' then
                        begin
                            write(outfile,PrefixText[J]);
                           Case J of
                              1: write(outfile,Timestamp,'}');
                              3: write(outfile,fullname,'}');
                           end;
                           Writeln;
                        end;
                     while not eof(infile) do
                     begin
                         Readln(Infile, Line);
                         writeln(outfile, Line);
                     end;
                     For J := 1 to 10 do
                        if SuffixText[J]<>'' then
                        begin
                            write(outfile,SuffixText[J]);
                           Case J of
                              1: write(outfile,Timestamp,'}');
                              3: write(outfile,fullname,' exited }');
                           end;
                           Writeln;
                        end;
                     Close(OutFile);
                     Close(Infile);
                     inc(GlobalFileCount);
                     Write('           ',#13,globalFileCount,#13);
                     break
                 end;  // If TheExtension

          end;

      Until FindNext(rslt) <> 0;
      FindClose(rslt);
   end;






begin
      GetLocalTime(TS);
      TimeStamp := CTS(TS);
      ScanFiles(''); // Start Here


      writeln;
      writeln('Processed ',GlobalFileCount,' files.');

end.

