{$ifdef mswindows}{$apptype console}{$endif}
Program NoisyAdd;
// Simple, quick program to add prefix code at the beginning of a
// program, and suffix code, at the end of the program
//
// The compiler does look beyond the last period, so appending
// lines to a file will work
//
// Paul Robinson 2021-12-17

{$mode ObjFPC}{$H+}
uses
   windows, SysUtils;

Const
    // Text to insert at TOP of file
    PrefixText: Array [1..10] of String = (
    '{.Noisy - Header AutoGenerated ',  //< post processor will close comment
    '{.Noisy} {$IFDEF Noisy}',
    '{.Noisy} {$INFO Entered ', //< post processor adds file name here
    '{.Noisy} {$ENDIF}',
    '',
    '',
    '',
    '',
    '',
    ''
    );

    // text to insert at BOTTOM of file
    SuffixText: Array [1..10] of String = (
    '{.Noisy - Footer AutoGenerated ',  //< postprocessor will close comment
    '{.Noisy} {$IFDEF Noisy}',
    '{.Noisy} {$INFO ', //< postprocessoradds file name here
    '{.Noisy} {$ENDIF}',
    '',
    '',
    '',
    '',
    '',
    ''  
    );

    // These are the extensiobns we search
    Extensions: Array[1 .. 5] of String =(
    'pp',
    'pas',
    'inc',
    '',
    ''
    );

   // Standard months of year
   Months: array[1..12] of string[9]=
            ('January',   'February','March',    'April',
              'May',      'June',    'July',     'August',
              'September','October', 'November', 'December');

    // Standard days of week
    Days: Array[0..6] of string[9]=
            ('Sunday','Monday','Tuesday','Wednesday',
            'Thursday','Friday','Saturday');

    path = '*';             //< file names to pick up
    Attr = faAnyFile  ;     //< take any file name
    SlashChar = '\';        //< directory separator

    Zero = Ord('0');        //< Character 0

    // verbosity options
    Verbose_NoCountFiles =  1; //< no running total
    Verbose_ShowFiles    =  2; //< show file names
    Verbose_CountLines   =  4; //< show file lines (implies 2)
    Verbose_CountDirs    =  8; //< count directories
    Verbose_ShowDirs     = 16; //< show directory names

Var
    // options
    Verbosity: integer =0;   //< How Noisy we are when running
    DryRun: Boolean = false; //< show but don't do if true


    IR,               //< IOResult save
    GlobalFileCount,  //< Files processed for running count
    DirCount,         //< Directories Found
    J,                //< Loop counter for # of lines inserted
    i: integer;       //< Loop counter for # of extensions processed

    Infile,           //< Source file
    Outfile: text;    //< Output File

    EndTS,             //< Completion Time Stamp
    TS: SystemTime;    //< Start time stamp
    TimeStamp: String; //< Text of time stamp



    // Converts a file name into directory, name, extension.
    // This removes the dot in the extension. To keep it,
    // remove the // in front of Ext := and insert it in
    // the line after it
    procedure SplitPath(const Path: UnicodeString; var Folder, Name, Ext: UnicodeString);
    var
        DotPos, SlashPos, i: Integer;
    begin
        Folder := '';
        Name := Path;
        Ext := '';

        DotPos := 0;
        SlashPos := 0;

        for i := Length(Path) downto 1 do
            if (Path[i] = '.') and (DotPos = 0) then
                DotPos := i
            else if (Path[i] = SlashChar) and (SlashPos = 0) then
                SlashPos := i;

        if DotPos > 0 then
        // The file name contains a period
        begin
            Name := Copy(Path, 1, DotPos - 1);
    //        Ext  := LowerCase(Copy(Path, DotPos, Length(Path) - DotPos + 1));
            Ext  := LowerCase(Copy(Path, DotPos+1, Length(Path) - DotPos + 1));
        end;

        if SlashPos > 0 then
        // The file name contains a directory separator character
        begin
            Folder := Copy(Path, 1, SlashPos);
            Name   := Copy(Path, SlashPos + 1, Length(Name) - SlashPos);
        end;

    end;

// creates a text timestamp
  Function CTS(Const CTime:SystemTime): AnsiString;
begin
   Result := Days[CTime.dayOfWeek]+
             ' '+Months[CTime.month]+
             ' '+IntToStr(CTime.day)+
             ', '+IntToStr(CTime.year)+
             ' '+IntToStr(CTime.Hour)+
             ':';
   if CTime.Minute < 10 then Result := Result+'0';
   Result := Result+ IntToStr(CTime.Minute)+':';
   if CTime.Second < 10 then Result := Result+'0';
   Result := Result+ IntToStr(CTime.Second);
end;

Function ShowPlural(N:LargeInt; Plu:String; Sng: String): string;
Var
   s:String;
Begin
     If n<>1 Then
        Result:= S+ Plu
     Else
        Result := S + Sng;
End;

 

Function Comma(K:LargeInt):string;
var
   i:integer;
   s: string;
begin
    S := IntToStr(K);
    i := length(s)-3;
    while i>0 do
    begin
        S := Copy(S,1,i) +','+copy(s,i+1,length(s));
        I := I-3;
    end;
    Result := S;
end;


  // Recursively scan directories
  Procedure ScanFiles(
              Const Prefix: UnicodeString);  //< from where are we searching?
  var
     Rslt: TUnicodeSearchRec;    //< since this proc is recursive,
                                 //< this must be local
     LineCount: Integer;
     FullName,     //< Full name of input file
     Backup,       //< Name of backup file
     Line,         //< A line read from the input file
     TheFilePath,  //< File name split into path
     TheNameOnly,  //< File Name w/o extenion
     TheExtension: UnicodeString; //< File Name extension

     // Determine if a file is a directory
     Function isDirectory: boolean;
     begin
       result := (rslt.Attr And faDirectory) = faDirectory;
     end; // Function isDirectory

      // try to put file back if there was am error
     procedure putback;
     begin // try to put file back
         close(infile);
         if renameFile(backup,FullName) then // we did
             Writeln('?Error ',IR,' Unable to read file "',
                     FullName,'" file skipped')
         else                   // can't put it back
             Writeln('Unable to restore file "',
                      FullName,'", renamed to ',Backup,
                     '" file skipped');
     end;  // procedure putback;

  // the real "meat" of this program. Recursively scan all directories
  // to find the files having the extensions we use
  begin //< procedure scanfiles

      // Each time we enter this procedure, we have found another directory
      Inc(DirectoryCount);

      // Open the directory and get first file
      // this will probably be . or ..
      if (verbose  and  Verbose_CountDirs)=1  or
         (verbose  and  Verbose_ShowDirs_=1 then
      begin
         IF (verbose  and  Verbose_CountDirs)=1 THEN
             Write(Commaa(DirectoryCount):10,' Director',
             Plural(DirectoryCount,'ies','y'),' ');
          f ((verbose and Verbose_ShowDirs)=1)  then
             Write(Prefix);
          Writeln;
      end;
      If FindFirst(Prefix+Path,Attr,rslt) = 0 Then
      // If there are any files, pick them
       Repeat
          // skip parent directory and self
          If (rslt.Name = '.') Or  (rslt.Name = '..') Then
              continue;

          if isDirectory then     //< don't collect directory
                                  //< but do scan it
          begin
                 ScanFiles(prefix+rslt.Name+SlashChar)  //< recursive search
          end
          else    // NOT a directory
          begin   // split the file name into components
             SplitPath(rslt.name,TheFilePath,TheNameOnly,TheExtension);

             // search the array of preferred extensions
             For I := 1 to 5 do
               if Extensions[I]<>'' then   //< cjeck this extension
                 If theExtension = Extensions[I] then  //< found it
                 begin           //< We do want this one
                     FullName := Prefix+rslt.name;   //< Get the original name
                     Backup   := FullName + '.bak';  //< Get the nackup name
                     if not dryrun then
                     begin
                         // rename to Fullname + .bak, e.g pascal.pas.bak
                         if FileExists(Backup) then
                         // erase old backup
                             If not DeleteFile(Backup) then
                             // Error deleting previous backup
                             begin
                                 Writeln('Uname to delete backup of "',
                                         FullName,'" file skipped');
                                 break;  // exit FOR I loop
                             end;   // If file exists
                        // If we can't rename the file to the baxkup
                        // name, that's an error so bail out
                         if not renameFile(FullName,backup) then
                         begin
                         // tell them cam't backup
                             Writeln('Unable to backup file "',
                             FullName,'" file skipped');
                         // bail
                             break;  //< exit FOR I loop
                         end;    // can't rename
                     // Open the source for reading
                         Assign(Infile,Backup);
                         FileMode := 0; // open input file force read only
                         {$I-} Reset(Infile); {$I+}
                         IR := IOResult;  //< Check if error
                         if IR<>0 then    //< sorry, error
                         begin // try to put it back
                             putback;
                             break;
                         end;
                         // if we are here, start copying
                         Assign(Outfile,Fullname); // name replacement
                         {$I-} Rewrite(Outfile); {$I+}  // create replacement
                         IR := IOResult;
                         if IR<>0 then        // then there's an error
                         begin // try to put it back
                             putback;
                             break;
                         end;
                         // Now we insert cvustomized message per file
                         For J := 1 to 10 do
                         if PrefixText[J]<>'' then // don't insert null items
                         begin
                             write(outfile,PrefixText[J]);
                             Case J of
                               1: write(outfile,Timestamp,'}');
                               3: write(outfile,fullname,'}');
                             end;
                             Writeln(outfile);
                          end;     // For, If
                          // now we can copy the file
                          LineCount := 0;
                          while not eof(infile) do
                          begin
                              Readln(Infile, Line);
                              Inc(LineCount);
                              writeln(outfile, Line);
                          end;

                          // Insert Footer
                          For J := 1 to 10 do
                              if SuffixText[J]<>'' then // don't insert null items
                              begin
                                  write(outfile,SuffixText[J]);
                                  Case J of
                                      1: write(outfile,Timestamp,'}');
                                      3: write(outfile,fullname,' exited }');
                                  end;
                                  Writeln(outfile);
                              end;  // fore J, if
                              Close(OutFile);     // Sve the new file
                              Close(Infile);
                     end;
                     inc(GlobalFileCount);
                     if (Verbosity and NoCountFiles) <> 0 then
                     begin
                        If (Verbosity and Verbose_ShowFiles) = 0 then
                        // Only show rolling counter if no options
                         Write(globalFileCount:8,#8#8#8#8#8#8#8#8);
                        else
                           Write(Comma(GlobalFileCount):10,'. ');
                     end;
                     if not DryRun then
                        If (Verbosity and Verbose_CountLines)<>0 then
                          write(Comma(LineCount):9,' Lines: ');
                     If (Verbosity and Verbose_ShowFiles) <> 0 then
                        Write(Fullname);
                     if Verbosity > NoCountGiles then
                        Writeln;
                      end;
                     break
                 end;  // If TheExtension
           end;

       // get the next file
       Until FindNext(rslt) <> 0;   // If, Repeat
      FindClose(rslt);
   end;  //< procedure scanfiles

Procedure Banner;
begin

   Writeln('NoisyAdd - Add compiler flags to Pascal source files');
   writeln('Preparing to mark all .pas. .pp, and .inc files in this ');
   Writeln('directory and all subdirectories.');
   writeln('Started: ',TimeStamp,', please wait...');

end;  // rocedure Banner

Function Plural(N:Integer; Plu:String; Sng: String): string;
Var
   s:String;
Begin
    S := IntToStr(N);
    S := ' '+S+' ';
    If n<>1 Then
        Result:= S+ Plu
     Else
        Result := S + Sng;
End;  // Function Plural

Procedure Elapsed(CONST StartTime,EndTime: SystemTime);
Var
   H,M,S,MS: Integer;
   TimeString: String;

Begin
    // Now tell them how long it took
    // Presumably this program did not run for days...

    H :=  EndTime.Hour;
    if StartTime.Hour < EndTime.Hour  then
        h:=H + 24;
    h := h - StartTime.Hour;
    M := EndTime.Minute ;
    if M < StartTime.minute then
    begin
        H := H-1;
        M := M+60;
    end;
    M := M - StartTime.minute;
    S := EndTime.second  ;
    if S < StartTime.second then
    BEGIN
        M := M-1;
        S := S+60;
    END;
    S := S-StartTime.second;
    MS := EndTime.MilliSecond;
    IF MS < StartTime.MilliSecond then
    begin
        MS := MS+1000;
        S := S-1;
    end;
    MS := MS-StartTime.MilliSecond;

// we won't bother with days,
// nobody is going to process something taking that long

    TimeString := '';   // Make sure it has nothing left over
    If H >0 then
        Timestring := Plural(H,'hours','hour')+' ';
    If M >0 then
        Timestring := TimeString + Plural(M,'minutes','minute')+' ';
    if timestring <> '' then
        Timestring := Timestring +' and';
    Timestring := TimeString + IntToStr(S)+'.' + IntToStr(MS)+' seconds.';
    Writeln('Elapsed time: ',TimeString)
end;  // Procedure Elapsed

// read any command-line options
FUNCTION GetOpt:Boolean;
Var

    Arg,               //< Current command-line argument/parameter
    ArgUC:AnsiString;  //< Upper case version of Arg
    OK: Boolean;       //< Number processed OK
    ArgStart,          //< Point where parameter starts
    DoVerbose,         //< Position of verbose argument
    Errors,            //< Number of errors detected
    K:integer;         //< Number of command options
begin
   if Paramcount <1 then
      Exit;            //< There aren't any
   Errors := 0;
   For K := 1 to ParamCount do
   begin
       ArgStart:= 0;
       OK := FALSE;
       Arg := ParamStr(K);
       if (Copy(Arg,1,1) = '/') or (Copy(Arg,1,1) = '-') then
           ArgStart := 2
       else if (Copy(Arg,1,2) = '--') then
           ArgStart := 3;
       if ArgStart<>0 then
       begin
          ArgUC := UpperCase(Copy(Arg,ArgStart,Length(Arg)-ArgStart));
          Arg := Copy(Arg,ArgStart,Length(Arg)-ArgStart); // Trim command
          Case ArgUC[1] of
             'V': Begin
                      if Length(Arg)=0 then
                         begin
                             Writeln('Version ', Version);
                             Inc(Errors); // so program quits
                             Break;
                         end
                      else
                      begin
                          Verbosity := 0;
                          if Arg[1]=':' then
                             Arg := Copy(Arg,2,Length(Arg)-1); // discard colon
                          if Arg[1] in ['0'..'9'] then
                          Begin
                              While Arg[1] in ['0'..'9'] do
                              begin  // eat digits to retrieve number
                                  Ok := True;
                                  Verbosity := Verbosity*10+Ord(Arg[1])-Zero;
                                  Arg := Copy(Arg,2,Length(Arg)-1);
                                  if arg = '' then break;
                              end;
                              if Verbosity = Verbose_CountLines then
                                  Verbosity :=  Verbosity + Verbose_ShowFiles;
                              if OK then Continue;   // exit to FOR loop
                          end;
                      end;
                      Writeln('?Invald verbosity argument: ',Arg);
                      Inc(Errors); // so program quits
                  End;  // Case 'V'
                'H','?':
                 begin
                     Writeln('Usage ', ParamStr(0),' [argument ... ]');
                     Writeln('  Where "argument" is: ');
                     writeln('    /h -h or --h -- show this help *');
                     writeln('    /v -v or --v -- show version number *');
                     writeln('    /v<n> -- set verbosity level');
                     writeln('    Where <n> is: ');
                     writeln('       0 - Show running count of files');
                     writeln('      ',Verbose_NoCountFiles:2,
                                     ' - Don''t show running count');
                     writeln('      ',Verbose_ShowFiles:2,
                                     ' - Show file name being processed');
                     writeln('      ',Verbose_CountLines:2,
                                     '  - Show # of lines in file (implies ',
                                          Verbose_ShowFiles,')');
                     writeln('      ',Verbose_CountDirs:2,
                                     ' - Count directories being processed');
                     writeln('      ',Verbose_ShowDirs:2,
                                     ' - Show directory name being processed');
                     writeln('      Add values to combine results, e.g.');
                     writeln('       /v1 -- be quiet; /v10 -- show file ',
                                     'and directory names');
                     writeln('    /dr, -dr or --dryrun -- show what files ',
                                  'would be processed but take no action *');

                      Writeln;
                      Writeln('* means program will exit without action');
                      Writeln('Arguments are not case sensitive');
                      Inc(Errors); // so program quits
                  end;
             'D': Begin
                      IF (ArgUC ='DR') or (ArgUC ='DRYRUN') then
                        begin
                            DryRun := TRUE;
                            Continue;
                        end
                      ELSE
                      Begin
                          Writeln('?Invald argument: ',Arg);
                          Inc(Errors);
                      end;
                    end

          else  // CASE
              Writeln('?Invalid parameter: ',Arg, ' try /h or -h for info.');
               end;
              Inc(Errors); // so program quits
          end; // CASE
       end;
   Result := Errors = 0;
   exit;
end;

begin   // .Main.
      TS.Year:=0; EndTS.Month:= 0 ;      //< silence compiler warning
                                         //< about uninitialized variables
      GetLocalTime(TS);
      TimeStamp := CTS(TS);
      Banner;
      if not GetOpt then halt(1);
      if not dryrun then
      begin
          writeln('If you have run this by mistake, run NoisyDel ');
          writeln('to reverse any changes.');
      end;
      writeln;
      ScanFiles(''); // Start Here


      writeln;
      GetLocalTime(EndTS);
      TimeStamp := CTS(EndTS);
      Writeln('Completed ',TimeStamp);
      writeln('Processed ',GlobalFileCount,' files.');
      Elapsed(TS,EndTS);
      writeln;

      

end.     // .Main.
